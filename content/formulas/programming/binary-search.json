{
  "id": "binary-search",
  "name": "Binary Search Algorithm",
  "latex": "\\text{Time: } O(\\log n), \\quad \\text{Space: } O(1)",
  "explanation": "Binary search finds an element in a sorted array by repeatedly dividing the search space in half. Compare target with middle element, then search left or right half. This is one of the most efficient search algorithms. Requires sorted data. Used in databases, search engines, and any application needing fast lookups in ordered data.",
  "examples": [
    {
      "problem": "Search for 7 in sorted array [1, 3, 5, 7, 9, 11, 13]",
      "solution": "Found at index 3",
      "steps": [
        "Start: left=0, right=6, mid=3",
        "Compare: arr[3] = 7, target = 7",
        "Match found! Return index 3"
      ]
    },
    {
      "problem": "How many comparisons needed to find element in 1000-element array?",
      "solution": "At most 10 comparisons (log\u2082(1000) \u2248 10)",
      "steps": [
        "Binary search halves search space each step",
        "1000 \u2192 500 \u2192 250 \u2192 125 \u2192 62 \u2192 31 \u2192 15 \u2192 7 \u2192 3 \u2192 1 \u2192 found",
        "Maximum log\u2082(1000) \u2248 10 comparisons"
      ]
    }
  ],
  "prerequisites": [
    "logarithm-properties"
  ],
  "related": [
    "big-o-notation",
    "sorting-algorithms"
  ],
  "level": "algebra-1",
  "tags": [
    "programming",
    "algorithms",
    "searching",
    "binary-search"
  ],
  "topic": "programming",
  "proof": "O(log n) search in sorted array. Compare target to middle element. If equal, found. If target < middle, search left half. If target > middle, search right half. Repeat. Each step eliminates half of remaining elements. Maximum comparisons = \u2308log\u2082(n)\u2309."
}